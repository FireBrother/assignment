# 课程实践题 3 指令系统设计
---
吴先 1300012817

## 指令系统设计
>Q: 独立设计一个指令系统,并利用设计的指令实现冒泡排序算法。

### 寄存器
共有16个16位寄存器。

|编号	|名称	|功能	|
|-------|------|-------|
|$0		|zero	|存放常数0|
|$1		|rv		|保留（我还没想好让它干啥）|
|$2		|ip		|程序计数器|
|$3		|sp		|栈指针	|
|$4~$11	|t0~t7	|临时寄存器|
|$12~$15|s0~s3	|保存寄存器|

### 指令编码
指令集采用16位编码，只需要一种编码格式：

#### I型指令
|15..14|13..10|9..6|5..0|
|------|------|----|----|
|op    |rs    |rt  |imm |

（本来想加一个xchg交换指令，然后把R型指令设计成二地址代码；后来发现压根用不上xchg，直接交叉写入内存就好。。我一开始脑子应该是进地沟油了。。于是整个R型指令都用不着了）

### 指令集
| WISBS |(Wu Instruction Set For Bubble Sort)|   |   |
|-----	|-------|---|---|
|助记符	|op编码  |指令格式|指令含义|
|lw		|00		|lw $rt, $rs, imm|rt <- mem[rs+(sign-ext)imm]|
|sw		|01		|sw $rt, $rs, imm|mem[rs+(sign-ext)imm] <- rt|
|addi	|10		|add $rt, $rs, imm|rt <- rs + (sign-ext)imm  |
|ble	|11		|ble $rt, $rs, imm|if (rt <= rs) ip <- ip+4+(sign-ext)imm<<1| 

### 汇编指令（及伪指令）
* `.data`标明接下来为数据部分。其后的数据被放置在地址空间的低`0x7fff`中。

  数据部分的数据都被认为是16位有符号整数。`d(x, t)`表示将x拷贝t次，从低地址开始填充在地址空间中。

  规定sp寄存器指向数据部分的起始位置。

* `.edata`标明数据部分结束。

* `.code`标明接下来为代码部分。其后的数据被放置在地址空间的高`0x7fff`中（即从`0x8000`开始）。

  规定ip寄存器指向代码部分的起始位置。

* `.ecode`标明代码部分结束。

* `Lable:`用冒号标明一个符号，其值为当前的地址。

* 关于`ble`指令的说明：汇编代码中可以使用Label来做为`ble`指令的imm部分，编译时对imm部分进行回填，使其满足WISBS的编码要求。

## 数据通路及控制逻辑
### 完整系统
![](/Users/wuxian/Desktop/mprc_hw3/数据通路.jpg)

### lw指令
![](/Users/wuxian/Desktop/mprc_hw3/数据通路lw.jpg)

### sw指令
![](/Users/wuxian/Desktop/mprc_hw3/数据通路sw.jpg)

### addi指令
![](/Users/wuxian/Desktop/mprc_hw3/数据通路addi.jpg)

### ble指令
![](/Users/wuxian/Desktop/mprc_hw3/数据通路ble.jpg)

## 冒泡排序
### 代码

	    .data
	    src: 10 9 8 7 6 5 4 3 2 1
	    .edata
	
	    .code
	    addi $t3, $zero, 20
	
	    addi $s0, $zero, 0
	L1: ble $t3, $s0, EL1
	
	    addi $s1, $s0, 0
	L2: ble $t3, $s1, EL2
	
	    lw $t0, $s0, src
	    lw $t1, $s1, src
	
	    ble $t1, $t0, IF
	    ble $zero, $zero, EI
	IF: sw $t1, $s0, src
	    sw $t0, $s1, src
	EI:
	    addi $s1, $s1, 2
	    ble $zero, $zero, L2
	EL2:
	    addi $s0, $s0, 2
	    ble $zero, $zero, L1
	EL1:
	    .ecode

### 执行指令数
10个数，一共要进行`(10*(10+1))/2=55`次比较，每次比较需要3条指令，跳转需要1条指令；比较后如果需要交换，则需要额外2条指令，否则需要1条指令。每次循环需要3条指令进行循环变量的增加以及跳转。
一共需要`2+10*2+55*8.5+10*2=501.5`条指令。

根据模拟器模拟，对于数据`10 9 8 7 6 5 4 3 2 1`，一共需要492条指令。

## 指令级模拟器
### 简介
模拟器实现了一个伪｀编译器（实际上只是做了地址回填和译码的功能），将“编译”好的二进制文件放入模拟器运行，可以实时检查内存和寄存器状态，显示当前执行的代码。
### 运行截图
![](/Users/wuxian/Desktop/mprc_hw3/snapshot.jpeg)
### 运行日志
请见附件`log`，日志包含了编译时期的信息，包括：

* symbal_map 符号链接表
* wasm 地址回填后的代码
* binary_file 编译后的文件，由数据部分和代码部分组成

还包含了模拟运行时期的信息，从start simulation开始，按照此格式进行记录：

* 指令数 代码地址 op字段 rs字段 rt字段 imm字段
* 后跟随寄存器信息，8个寄存器一行
* 如果是sw指令，后跟随内存信息，只输出了数据部分的内存

从日志结尾的内存信息可以看到，全部10个数据被正确排序。

